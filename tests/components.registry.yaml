compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state, imports }) => {
          const projectRoot = state.projectPath || '.';
          const joinPath = async (base, segment) => {
            const resolved = await imports.pathJoin({ base, segment });
            const candidate = resolved?.path ?? `${base.replace(/\/$/, '')}/${segment}`;
            return candidate;
          };
          const componentsRoot = await joinPath(projectRoot, 'components');
          const stack = [componentsRoot];
          const visited = new Set();
          const components = [];
          while (stack.length > 0) {
            const current = stack.pop();
            if (!current || visited.has(current)) {
              continue;
            }
            visited.add(current);
            const listing = await imports.fsListDir({ path: current });
            const entries = Array.isArray(listing?.entries) ? listing.entries : [];
            let hasDescriptor = false;
            let hasCompose = false;
            for (const entry of entries) {
              if (!entry || typeof entry !== 'object') continue;
              const entryPath = await joinPath(current, entry.name);
              if (entry.type === 'directory') {
                stack.push(entryPath);
              } else if (entry.type === 'file') {
                if (entry.name === 'lcp.toml') hasDescriptor = true;
                if (entry.name === 'compose.yaml') hasCompose = true;
              }
            }
            if (hasDescriptor && hasCompose) {
              const descriptorPath = await joinPath(current, 'lcp.toml');
              const composePath = await joinPath(current, 'compose.yaml');
              try {
                const descriptorRaw = await imports.fsReadFile({ path: descriptorPath, encoding: 'utf-8' });
                const descriptorText = typeof descriptorRaw?.data === 'string' ? descriptorRaw.data : descriptorRaw;
                const match = /(^|\n)\s*id\s*=\s*"([^"]+)"/.exec(descriptorText);
                if (!match) {
                  throw new Error('missing id field');
                }
                const id = match[2];
                components.push({ id, composePath });
              } catch (err) {
                throw new Error(`failed to register ${descriptorPath}: ${err?.message ?? err}`);
              }
            }
          }
          if (components.length > 0 && imports.register) {
            try {
              await imports.register({ components });
            } catch (err) {
              const message = err?.message ?? String(err);
              if (!/Function not registered/.test(message)) {
                throw err;
              }
            }
          }
          return { components };
        }
      input:
        projectPath: $.projectPath
      imports:
        fsListDir: lcod://contract/core/fs/list-dir@1
        fsReadFile: lcod://contract/core/fs/read-file@1
        pathJoin: lcod://axiom/path/join@1
        register: lcod://tooling/resolver/register@1
    out:
      registryComponents: components

  - call: lcod://axiom/path/join@1
    in:
      base: $.projectPath
      segment: "../../tests/fixtures/registry"
    out:
      registryRoot: path

  - call: lcod://axiom/path/join@1
    in:
      base: $.projectPath
      segment: "../../tests/fixtures/registry_invalid"
    out:
      registryInvalidRoot: path

  - call: lcod://axiom/path/join@1
    in:
      base: $.registryRoot
      segment: "catalog.json"
    out:
      registryCatalogPath: path

  - call: lcod://axiom/path/join@1
    in:
      base: $.registryInvalidRoot
      segment: "catalog.json"
    out:
      registryInvalidCatalogPath: path

  - call: lcod://tooling/registry_catalog/collect@0.1.0
    in:
      rootPath: $.registryRoot
      catalogPath: $.registryCatalogPath
    out:
      collectResult: $

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const result = state.collectResult;
          if (!result || typeof result !== 'object') {
            throw new Error('collect: result missing');
          }
          if (!Array.isArray(result.warnings) || result.warnings.length !== 0) {
            throw new Error('collect: warnings should be empty');
          }
          if (!Array.isArray(result.packages) || result.packages.length !== 1) {
            throw new Error('collect: expected a single package entry');
          }
          const pkg = result.packages[0];
          if (pkg.id !== 'lcod://example/pkg') {
            throw new Error(`collect: unexpected package id ${pkg.id}`);
          }
          if (!Array.isArray(pkg.versions) || pkg.versions.length !== 1) {
            throw new Error('collect: expected a single version entry');
          }
          const version = pkg.versions[0];
          if (version.version !== '1.0.0') {
            throw new Error(`collect: unexpected version ${version.version}`);
          }
          if (version.manifest !== 'packages/example/pkg/1.0.0/manifest.json') {
            throw new Error('collect: unexpected manifest path');
          }
          return {};
        }
      input:
        collectResult: $.collectResult

  - call: lcod://tooling/registry_catalog/validate@0.1.0
    in:
      rootPath: $.registryRoot
      catalogPath: $.registryCatalogPath
    out:
      validateResult: $

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const result = state.validateResult;
          if (!Array.isArray(result.errors) || result.errors.length !== 0) {
            throw new Error('validate: expected no errors for valid catalog');
          }
          return {};
        }
      input:
        validateResult: $.validateResult

  - call: lcod://tooling/registry_catalog/validate@0.1.0
    in:
      rootPath: $.registryInvalidRoot
      catalogPath: $.registryInvalidCatalogPath
    out:
      validateInvalid: $

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const result = state.validateInvalid;
          if (!Array.isArray(result.errors) || result.errors.length === 0) {
            throw new Error('validate: expected errors for invalid catalog');
          }
          const duplicate = result.errors.find((err) => typeof err === 'string' && err.includes('duplicate package id lcod://example/pkg'));
          if (!duplicate) {
            throw new Error('validate: missing duplicate package error');
          }
          return {};
        }
      input:
        validateInvalid: $.validateInvalid

  - call: lcod://tooling/registry_catalog/refresh@0.1.0
    in:
      rootPath: $.registryRoot
      catalogPath: $.registryCatalogPath
    out:
      refreshResult: $

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const result = state.refreshResult;
          if (!result || typeof result !== 'object') {
            throw new Error('refresh: result missing');
          }
          if (!Array.isArray(result.errors) || result.errors.length !== 0) {
            throw new Error('refresh: expected no validation errors');
          }
          if (!Array.isArray(result.warnings) || result.warnings.length !== 0) {
            throw new Error('refresh: expected no warnings');
          }
          if (!Array.isArray(result.packages) || result.packages.length !== 1) {
            throw new Error('refresh: unexpected packages length');
          }
          return {};
        }
      input:
        refreshResult: $.refreshResult
