compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state, imports }) => {
          const joinPath = async (base, segment) => {
            const resolved = await imports.pathJoin({ base, segment });
            return resolved?.path ?? `${base.replace(/\/$/, '')}/${segment}`;
          };
          const projectRoot = state.projectPath || '.';
          const root = state.rootPath || await joinPath(projectRoot, 'components');
          const errors = [];
          const components = [];

          const listDir = async (dir) => {
            try {
              const result = await imports.fsListDir({ path: dir });
              return Array.isArray(result?.entries) ? result.entries : [];
            } catch (err) {
              errors.push(`fs/list-dir failed for ${dir}: ${err?.message ?? err}`);
              return [];
            }
          };

          const fileExists = async (file) => {
            try {
              await imports.fsReadFile({ path: file, encoding: 'utf-8' });
              return true;
            } catch (err) {
              if (err && (err.code === 'ENOENT' || err.message?.includes('ENOENT'))) {
                return false;
              }
              throw err;
            }
          };

          const resolveChildPath = async (baseDir, entry) => {
            if (entry && typeof entry === 'object') {
              if (entry.relativePath) {
                const resolved = await joinPath(baseDir, entry.relativePath);
                return resolved;
              }
              if (entry.path && entry.path.startsWith('/')) {
                return entry.path;
              }
              if (entry.path) {
                const resolved = await joinPath(baseDir, entry.path);
                return resolved;
              }
              if (entry.name) {
                const resolved = await joinPath(baseDir, entry.name);
                return resolved;
              }
            }
            return baseDir;
          };

          const stack = [root];
          const visited = new Set();
          while (stack.length > 0) {
            const current = stack.pop();
            if (visited.has(current)) continue;
            visited.add(current);
            const entries = await listDir(current);
            let hasLcp = false;
            let hasCompose = false;
            for (const entry of entries) {
              if (!entry || typeof entry !== 'object') continue;
              if (entry.type === 'directory') {
                const childPath = await resolveChildPath(current, entry);
                if (childPath && !visited.has(childPath)) {
                  stack.push(childPath);
                }
              }
              if (entry.name === 'lcp.toml') hasLcp = true;
              if (entry.name === 'compose.yaml') hasCompose = true;
            }
            if (hasLcp && hasCompose) {
              components.push(current);
            }
          }

          for (const dir of components) {
            const rel = dir === root ? '.' : (dir.startsWith(root + '/') ? dir.slice(root.length + 1) : dir);
            const lcpPath = await joinPath(dir, 'lcp.toml');
            const readmePath = await joinPath(dir, 'README.md');

            let descriptor;
            try {
              const raw = await imports.fsReadFile({ path: lcpPath, encoding: 'utf-8' });
              const parsed = await imports.tomlParse({ text: raw?.data ?? raw });
              descriptor = parsed?.value ?? {};
            } catch (err) {
              errors.push(`${rel}: failed to read/parse lcp.toml (${err?.message ?? err})`);
              continue;
            }

            if (!descriptor.summary || typeof descriptor.summary !== 'string' || descriptor.summary.trim().length === 0) {
              errors.push(`${rel}: missing or empty summary`);
            }

            const isComponent = (descriptor.kind || '').toLowerCase() === 'component';

            const docs = descriptor.docs || {};
            const readmeRef = typeof docs.readme === 'string' && docs.readme.trim().length > 0
              ? docs.readme.trim()
              : 'README.md';
            const readmeExists = await fileExists(readmePath);
            if (!readmeExists) {
              errors.push(`${rel}: README.md not found (${readmeRef})`);
            }

            if (isComponent) {
              const inputsCount = descriptor.inputs && typeof descriptor.inputs === 'object'
                ? Object.keys(descriptor.inputs).length
                : Array.isArray(descriptor.io?.input)
                  ? descriptor.io.input.length
                  : 0;
              const outputsCount = descriptor.outputs && typeof descriptor.outputs === 'object'
                ? Object.keys(descriptor.outputs).length
                : Array.isArray(descriptor.io?.output)
                  ? descriptor.io.output.length
                  : 0;
              if (inputsCount === 0 && outputsCount === 0) {
                errors.push(`${rel}: missing input/output metadata`);
              }
            }
          }

          if (errors.length > 0) {
            throw new Error(errors.join('\n'));
          }
          return { count: components.length };
        }
      imports:
        fsListDir: lcod://contract/core/fs/list-dir@1
        fsReadFile: lcod://contract/core/fs/read-file@1
        pathJoin: lcod://axiom/path/join@1
        tomlParse: lcod://axiom/toml/parse@1
