compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, { imports }) => {
          const ensureString = (value) => (typeof value === 'string' && value.length ? value : null);
          const ensureObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : null);
          const ensureArray = (value) => (Array.isArray(value) ? value : []);

          const warnings = [];
          const registryMap = new Map();

          const downloadsRoot = ensureString(state.downloadsRoot) || '.';
          const sourcesConfig = ensureObject(state.sourcesConfig) || {};
          const sourcesBaseDir = ensureString(state.sourcesBaseDir) || '.';

          const defaults = ensureObject(sourcesConfig.defaults) || {};
          const defaultEntrypoint = ensureObject(defaults.entrypoint) || {};
          const basePriority = Number.isFinite(defaults.priority) ? Math.trunc(defaults.priority) : null;

          const enqueuePointers = async (entries, inherited, baseDirOverride) => {
            for (const entry of entries) {
              const normalized = await imports.normalizePointer({
                entry,
                inherited,
                baseDir: baseDirOverride,
                sourcesBaseDir,
                defaultEntrypoint,
                basePriority
              });
              if (normalized?.warnings?.length) warnings.push(...normalized.warnings);
              if (normalized?.pointer) queue.push(normalized.pointer);
            }
          };

          const ensureRegistrySource = (registryId, priority, defaultsEntry, metadata) => {
            const existing = registryMap.get(registryId);
            if (existing) {
              if (Number.isFinite(priority)) {
                if (!Number.isFinite(existing.priority) || priority < existing.priority) {
                  existing.priority = priority;
                }
              }
              if (!existing.defaults && defaultsEntry) existing.defaults = defaultsEntry;
              if (!existing.metadata && metadata) existing.metadata = metadata;
              return existing;
            }
            const entry = {
              id: registryId,
              type: 'inline',
              priority: Number.isFinite(priority) ? priority : undefined,
              defaults: defaultsEntry || undefined,
              metadata: metadata || undefined,
              lines: []
            };
            registryMap.set(registryId, entry);
            return entry;
          };

          const queue = [];
          const sources = ensureArray(sourcesConfig.sources);
          await enqueuePointers(sources, null, sourcesBaseDir);

          while (queue.length) {
            const pointer = queue.shift();
            const processed = await imports.processPointer({
              pointer,
              downloadsRoot,
              defaultEntrypoint,
              basePriority
            });
            if (processed?.warnings?.length) warnings.push(...processed.warnings);

            const children = ensureArray(processed?.children);
            if (children.length) {
              await enqueuePointers(children, pointer, pointer.baseDir);
            }

            const entry = ensureObject(processed?.entry);
            if (entry && Array.isArray(entry.lines) && entry.lines.length) {
              const effectivePriority = Number.isFinite(entry.priority) ? entry.priority : null;
              const target = ensureRegistrySource(
                entry.id,
                effectivePriority,
                entry.defaults,
                entry.metadata || pointer.metadata
              );
              for (const line of entry.lines) {
                target.lines.push(line);
              }
            }
          }

          const registrySources = Array.from(registryMap.values())
            .filter((entry) => entry.lines.length > 0)
            .map((entry) => {
              const cleaned = { id: entry.id, type: entry.type, lines: entry.lines };
              if (Number.isFinite(entry.priority)) cleaned.priority = entry.priority;
              if (entry.defaults) cleaned.defaults = entry.defaults;
              if (entry.metadata) cleaned.metadata = entry.metadata;
              return cleaned;
            });

          return { registrySources, warnings };
        }
      input:
        sourcesConfig: $.sourcesConfig
        sourcesBaseDir: $.sourcesBaseDir
        downloadsRoot: $.downloadsRoot
      imports:
        normalizePointer: lcod://tooling/registry_sources/normalize_pointer@0.1.0
        processPointer: lcod://tooling/registry_sources/process_pointer@0.1.0
    out:
      registrySources: registrySources
      warnings: warnings
